
기초적인 객체지향 원리에 대해 제대로 이해할 필요가 있으므로 객제치향 프로그래밍에 대해 알아보자.   
   
   
## 클래스와 객체   
   
객체지향성에 대한 정의는 매우 다양하고 확실하게 공감대가 형성되어 있지않지만, 클래스와 객체가 중심에 있다.   
클래스(class)는 속성(attribute, 성질(property)이나 상태(state)라고도 부름)과 행동(actions, 능력(capability) 또는 메소드(method)라고도 부름)을 가진 무언가를 *추상적으로 정의한 것이다.*   
   
**객체(object)** 는 다른 객체 인스턴스와는 다른 별도의 상태를 가지고 있는 어떤 클래스의 특정 인스턴스를 뜻한다.   
   
직교좌표계에서 어떤 점의 x값과 y값을 나타내는 한 쌍의 정수가 들어있는 Point라는 클래스는 다음과 같이 정의할 수 있다.   

<pre>
  <code>
    public class Point {
      private int x;
      private int y;
      
      public Point(int x, int y) {
        this.x = x;
        this.y = y;
      }
      
      public Point( Point other ) {
        x = other.getX();
        y = other.getY();
      }
      
      public int getX() { return x; }
      
      public int getY() { return y; }
      
      public Point relativeTo( int dx, int dy ){
        return new Point( x + dx, y + dy );
      }
      
      public String toString() {
        StringBuffer b = new StringBuffer();
        b.append( '(' );
        b.append( x );
        b.append( ',' );
        b.append( y );
        b.append( ')' );
          return b.toString();
      }
  }
  </code>
</pre>
   
   
어떤 점을 표현하려면 적당한 값을 가지고 Point 클래스의 인스턴스를 만들기만 하면 된다.   
   
<pre>
  <code>
    Point p1 = new Point( 5, 10 );
    Point p2 = p1.relativeTo( -5, 5);
    System.out.println( p2.toString() ); // (0, 15) 출력
  </code>
</pre>
   
이 간단한 예에도 객체지향 프로그래밍의 중요한 원칙 가운데 하나인 **캡슐화(Encapsulation)** 가 포함되어 있다.    

## 상속과 다형성
   
다른 두 가지 중요한 원칙으로 **상속**과 **다형성**이 있는데, 이 둘은 서로 밀접하게 연관되어 있다.   
**상속**(inheritance)은 어떤 클래스에서 더 특화된 버전의 클래스를 위한 행동을 제공할 수 있게 해준다.   
  - B라는 클래스가 A라는 클래스로부터 상속을 받으면, A는 B의 부모 또는 베이스 클래스가 되며, B는 A의 서브클래스가 된다.   
    A 클래스에서 정의한 행동은 모두 B 클래스의 행동이 되며, 일부를 변형할 수도 있다.   
    그리고 A 클래스의 인스턴스가 필요한 곳이라면 어디에든 B 클래스를 사용해도 된다.   
    
**다형성**(Polymorphism)은 한 행동을 여러 방법으로 구현하고 상황에 따라 적당한 구현을 선택해서 쓸 수 있도록 해주는 기능을 제공.   
  - 예를 들어, 한 클래스에서 서로 다른 매개 변수를 써서 한 메소드를 두 가지 버전으로 정의할 수 있다.   
    아니면, 부모 클래스와 서브클래스에서 같은 메소드를 다르게 정의하여 서브클래스의 인스턴스에 대해서는 서브클래스에서 정의한 메소드가 부모 클래스에서 정의한 메소드를 오버라이드(override)하도록 할 수 있다.   
   
상속과 다형성의 대표적인 예로 벡터 기반으로 그림을 그리는 어플리케이션에서 서로 다른 도형을 나타내는 도형 라이브러리를 생각할 수 있다.   
   
## 생성과 파괴   
   
*객체*는 *클래스의 인스턴스*다.   
      
객체를 제거하는 것은 객체를 생성하는 것보다 좀 더 복잡하다.   
C++ 에서는 파괴자(destructor)라는 메소드를 호출하여 객체의 상태를 모두 제거한다.   
*메모리 유출을 방지하려면 객체 인스턴스를 잘 관리해야만 한다.*   
하지만, C# 이나 자바 같은 언어에서는 가비지 컬렉터가 더 이상 쓰이지 않는 객체를 찾아서 파괴하는 일을 맡아서 처리하며, 이런 경우에는 언제 어디서 객체가 파괴될지는 어플리케이션에서 제어할 수 있는 부분이 아니다.   
   
## 객체지향 프로그래밍 문제
   
객체지향 프로그래밍과 관련하여 나오는 문제에서는 주로 그 회사에서 코딩할때 사용하는 언어와 연관된 주제를 중심으로 이론에 대한 내용을 다룬다.   
   
### 인터페이스와 추상 클래스   
   
<pre>
  객체지향 프로그래밍에서 인터페이스와 추상 클래스 사이의 차이점을 설명하라.   
</pre>
   
이 문제의 정답은 어떤 언어를 사용하는지에 따라 달라지겠지만, 우선 몇가지 일반적인 정의부터 시작해보자.   

  * **인터페이스(interface)** 에서는 **클래스와 무관하게 일련의 연관된 메소드**들을 선언한다.   
  * **추상 클래스(abstract class)** 는 **메소드를 선언하기는 하지만 모든 메소드를 정의하지는 않는 불완전하게 정의된 클래스**이다.   
   
따라서 개념 면에서 보면 **인터페이스**는 클래스 계층 구조와는 *독립적으로* 어플리케이션 프로그래밍 인터페이스(API, Application Programming Interface)를 정의하는 역할을 한다.   
인터페이스는 그 인터페이스를 *사용하는 사용자 입장에서는 메소드를 실제로 구현하는 클래스에 대해 아무것도 알 수 없기 때문에* 캡슐화의 정점에 서 있는 것으로 생각할 수 있다.   
어떤 클래스에서 인터페이스를 통해 멤버들을 공개하면 그 클래스는 그 인터페이스를 구현(implement)한다고 표현한다.   
   
인터페이스와 달리 **추상 클래스**는 그 자체가 클래스이다.   
데이터 멤버도 들어갈 수 있고 다른 클래스의 서브클래스로 만들 수도 있다.   
하지만 *구상(비추상) 클래스와 달리 행동 중 일부는 정의가 되어 있지 않고 서브클래스에서 정의해서 써야 한다.*   
이런 이유로 인해 추상 클래스의 인스턴스는 만들 수 없고, 그 클래스를 상속하는 구상 서브클래스의 인스턴스를 생성해서 써야 한다.   
   
**인터페이스는 데이터 멤버 및 메소드 정의가 들어있지 않은 추상 클래스와 거의 똑같다.**   
   
   
### 다중 상속
   
C++ 에서는 한 클래스에서 하나 이상의 클래스를 상속할 수 있으며, 이를 다중 상속(multiple inheritance)이라 부른다.   
하지만 C#과 자바에서는 단일 상속만 허용된다.   
   
한 어플리케이션에서 서로 다른 클래스 프레임워크를 사용한다든가 하는 경우에는 두 개의 서로 다른 클래스 계층 구조를 결합한 클래스를 만들어 써야 하는 경우가 있는데, 이런 경우에 다중 상속을 활용할 수 있다.   
예를 들어, 두 프레임워크에서 예외 상황을 서로 다른 베이스 클래스로 정의해 놓았다면 다중 상속을 써서 어느 프레임워크에서든 사용할 수 있는 예외 상황 클래스를 만들 수도 있다.   
   
하지만 다중 상속을 쓰다 보면 종종 애매한 상황이 벌어질 수 있다.   
대표적인 예로 한 클래스가 두 개의 서로 다른 클래스를 상속하는데, 그 두 부모 클래스가 한 클래스로부터 파생된 클래스인 경우를 들 수 있다.   

<pre>
   <code>
      class A{
         protected:
            bool flag;
      };
      
      class B : public A {};
      
      class C : public A {};
      
      class D : public B, public C {
         public:
            void setFlag (bool nflag) {
               flag = nflag;
            }
      };
      
   </code>
</pre>
   
이 예를 보면 flag 데이터 멤버는 A 클래스에서 정의되는데, D클래스는 B와 C라는 클래스의 서브클래스이며, B와 C는 둘 다 A의 서브클래스이므로, D의 클래스 계층 구조를 보면 A가 두 번 등장하게 되어 flag가 두 개 만들어지는 셈이 된다.   
즉, 어떤 것을 써야 할지 모르는 상황이 일어난다.   
따라서 컴파일러는 D에서 flag에 대한 리퍼런스가 모호하다는 메세지를 내보낸다.   
한가지 해결책으로 다음과 같은 식으로 레퍼런스를 명시적으로 표시하는 방법이 있다.   

<pre>
   <code>
      B:flag = nflag;
   </code>
</pre>
    
또 다른 방법은 B와 C를 가상 베이스 클래스로 선언하여 클래스 계층 구조에 A의 사본이 하나만 들어가도록 하는 방법이다.   

## 파이썬의 객체지향 프로그래밍
