

[기초적인 연결리스트 연산](##기초적인-연결-리스트-연산)

[연결 리스트 문제](#연결-리스트-문제)   
    [- 스택 구현법](###문제-1-스택-구현법)
    
    
    
---------------------------------------

# 개요   

연결 리스트(linked list)는 사실 워낙 간단해 보이지만 동적인 데이터를 처리하는 것과 관련된 수많은 문제의 근간을 이루는 자료구조.

효율적인 리스트 종주(traversal), 리스트 정렬, 리스트 앞이나 뒤쪽 끝에서의 삭제 또는 삽입에 대한 문제는 기초적인 자료구조 개념을 테스트하기에 더할 나위 없이 좋다. 리스트를 완벽하게 구현하는데 보통 10분이 채 걸리지 않기 때문에 문제를 푸는 시간은 충분하며 대조적으로 해시 테이블처럼 복잡한 자료구조는 구현하는 데만 많은 인터뷰 대부분의 시간을 차지한다.


* 연결 리스트의 종류  
  연결리스트는 3가지 유형으로 단일 연결 리스트(Singly-linked list), 이중 연결 리스트(doubly-linked list), 원형 연결 리스트(circularly-linked     lisat)이 존재한다.

인터뷰어가 "연결 리스트"라고만 말한다면 보통 단일 연결 리스트를 뜻함. 
단일 연결 리스트는 각각 다음 원소를 가리키는 next 포인터 또는 레퍼런스(연결 링크)가 들어있는 데이터 원소들로 구성된다.
리스트의 마지막 원소에는 빈 링크 또는 널 링크가 들어간다. 

  <pre>
  C이나 C++에서는 원소의 next포인터와 그 원소에 들어갈 데이터가 다음 코드에 있는 것처럼 하나로 묶여 있다. 

  <code>
    typedef struct intElement {
      struct intElement *next;
      int data;
    }intElement;
  </code>
  next 포인터를 구조체나 클래스 맨 앞 쪽에 넣어두면 그 원소에 어떤 데이터가 들어가든 제대로 동작하는 포괄적인 리스트 처리 루틴을 더 쉽게 만들 수 있다는 장점이 있다.
  </pre>
  
어떤 언어를 쓰든 단일 연결 리스트를 구현할 때는 몇가지 주의해야 할 특별 케이스 및 함정이 도사리고 있다.  
단일 연결 리스트의 연결 링크는 다음 원소를 가리키는 포인터(또는 레퍼런스)만으로 구성되기 때문에 리스트를 한 방향으로만 종주할 수 있다.  
__따라서 리스트를 완전히 종주하려면 반드시 첫 번째 원소부터 시작해야한다.__  
그래서 연결 리스트라는 용어를 어떤 연결 리스트의 첫 번째 원소라는 뜻으로 쓰는 경우도 종종 있다.   
   
*인터뷰어가 어떤 함수에서 인자로 연결 리스트를 받는다고 말하면, 그 연결리스트의 첫 번째 원소에 대한 포인터/레퍼런스를 인자로 받아들인다는 뜻으로 이해하면 된다.*

## 기초적인 연결 리스트 연산  

### 헤드 원소 추적
단일 연결 리스트에서는 반드시 헤드 원소를 추적해야 한다.  

<pre>
따라서 새로운 원소를 첫 번째 원소 앞에 추가한다거나 첫 번째 원소를 제거할 때 리스트의 헤드에 대한 포인터 또는 레퍼런스를 갱신해야 한다.
<code>
  bool insertInFront(intElement *head, int data){
    intElement *newElem = new intElement;
    if (!newElem) return false;
    
    newElem->data = data;
    head = newElem; // 틀렸음.
    return true;
}

</code>
</pre>


위 코드에서는 헤드 포인터에 대한 지역 변수 사본만을 갱신하기 때문에 이 코드는 제대로 작동하지 않는다. (함수 인자로 단일 포인터 사용.)   
제대로 작동하게 하려면 **헤드 포인터에 대한 포인터** 를 넘겨줘야 한다.
<pre>
<code>
  bool insertInFront(intElement **head, int data){
    intElement *newElem = new intElement;
    if (!newElem) return false;
    
    newElem->data = data;
    *head = newElem; // 더블 포인터를 사용하여 헤드의 주소를 갱신.
    return true;
}
</code>
</pre>

### 종주 

헤드 원소가 아닌 다른 리스트 원소를 가지고 작업을 해야하는 경우도 있다.  
연결 리스트의 첫 번째 원소가 아닌 원소에 대한 연산을 하려면 리스트에 있는 원소 중 일부를 종주해야 할 수도 있으며,   
   
*이때 항상 리스트가 끝나지 않는지 확인을 해야한다.*

<pre>
  아래에 있는 코드는 틀린 코드다. (java code)
<code>
  public intElement find(intElement head, Object data){
      while(head.data != data){
          head = head.next;
      }
      return head;
  }
</code>

리스트가 끝났는지 확인하기 위하여 head != null을 추가하여 리스트가 끝났는지 확인.

<code>
  public intElement find(intElement head, Object data){
    while(head != null && head.data != data){ 
        head = head.next;
    }
    return head;
  }
</code>
</pre>


### 원소의 삽입 및 삭제   

단일 연결 리스트에 있는 원소들은 다음 원소에 대한 링크를 통해서만 관리할 수 있기 때문에 중간에 있는 원소를 삽입 또는 삭제하려면, 그 앞 원소의 링크를 수정해야 한다.  
그리고 그 앞 원소를 알아낼 방법이 없기 때문에 **리스트를 종주해야 할 수 있다.**

<pre>
    리스트의 헤드 부분을 처리할 때는 한층 더 주의를 기울여야한다.
<code>
    bool deleteElement(intElement **head, intElement *deleteme){
      intElement *elem = *head;

      if (deleteme == *head) {
          *head = elem->next;
          delete deleteme;
          return true;
      }

      while(elem) {
          if(elem->next == deleteme){
              elem->next = deleteme->next;
              delete deleteme;
              return true;
          }
          elem = elem -> next;
      }
      // *deletme 가 없는 경우*
      return false;
  }
</code>

삭제 및 삽입을 하려면 삭제 및 삽입할 위치의 바로 앞에 있는 원소에 대한 포인터 or 레퍼런스가 필요.

</pre>

*한가지 더 신경 써야 할 문제.*    
   
연결 리스트에 있는 모든 원소를 삭제하고자 하는 경우.   
가장 쉽게 생각할 수 있는건 포인터 1개를 사용하여 리스트를 종주하면서 원소들을 하나씩 제거하는 방법.  
**BUT,** 실제로 구현하려고 하면 문제가 생김.   
다음 포인터로 넘어가는 작업과 원소를 제거하는 작업 중 어느 것을 먼저 해야할까?   
1. 다음 포인터로 넘어가는 일을 먼저 하면 제거해야할 원소의 포인터를 덮어쓴 상황이기 때문에 메모리 할당을 해제할 수가 없다.   
2. 제거를 먼저 해버리고 나면 방금 제거한 원소에 next 포인터가 사라져 다음 원소로 넘어가는 것이 불가능하다.   
     
<pre>
따라서, 다음 코드처럼 포인터를 2개 써야한다. 
<code>
    void deleteList(intElement **head){
      intElement *deleteme = *head;

      while(deleteme){
          intElement *next = deleteme->next;
          delete  deleteme;
          deleteme = next;
      }

      *head = NULL;
  }
</code>
</pre>

원소를 삭제할 때는 적어도 두 개의 포인터 변수가 필요.   
삽입할 때도 포인터 변수가 두 개 있어야 하는 것은 마찬가지지지만, 둘 중 하나는 리스트에 있는 원소를 위해 쓰이고, 다른 하나는 메모리 할당에 의해 반환되는 포인터용으로 쓰이기 때문에 삽입 연산에서 포인터를 한 개만 쓰는 실수를 범하는 일은 거의 없다. 


## 연결 리스트 문제   

인터뷰에서 접하게 될 만한 대표적인 연결 리스트 문제를 몇 가지 소개하자면 다음과 같다.   
 
    
### 문제 1 스택 구현법
<pre>
스택 자료 구조에 대해 논하라. 연결 리스트 또는 동적 배열(dynamic array)을 써서 C로 스택을 구현해 보고, 그 자료구조를 사용한 이유를 설명하라.   
완전하고 일관적이고 사용하기 편린한 스택 인터페이스를 설계하라.   
</pre>   

#### 문제 해석    

이 문제는 세가지를 중점적으로 살펴보기 위한 문제.    
    
    1. 기본적인 자료구조에 대한 지식
    2. 자료구조를 조작하기 위한 루틴을 만드는 능력
    3. 일련의 루틴에 대한 일관적인 인터페이스를 설계하는 능력
    
스택은 후입선출(LIFO, last-in-first-out) 자료구조로 원소는 들어간 순서와 반대 순서로 나온다.   
원소를 삽입하고 삭제하는 연산은 각각 Push, Pop.    
스택은 여러 개의 서브테스크로 나뉘는 테스크를 관리하는데 유용하게 쓰이는 자료구조.   
     
     
스택을 구현하는 방법으로 먼저 **동적 배열**을 사용할 수 있다.    
연결리스트에 대한 상대적인 장점은 **배열 원소에 대한 임의 접근**이 가능하다는 점(인덱스만 알면 즉시 접근 가능).    
하지만, 스택의 연산은 한 방향으로만 이루어지기 때문에 이 장점은 쓸모 없다.   
그리고, 동적배열이 커짐에 따라 배열의 크기를 조절해야 하고 그 과정에서 기존 배열의 모든 원소들을 옮겨야 하므로 시간이 오래 걸림.    
     
반대로 **연결리스트**에서는 각 원소마다 메모리를 동적으로 할당하며, 크기가 작은 원소를 다룰 때는 그에 따른 오버헤드 주의.     
특히 적당한 크기의 동적 배열을 사용하여 배열 크기를 자주 조절하지 않아도 되는 경우와 비교하면 속도가 많이 떨어질 수도 있다.    
* 일반적으로 동적 배열을 기반 스택이 연결리스트 기반 스택에 비하여 대체로 빠른편.   
    
인터뷰에서는 각각의 장단점을 설명하고 선호도에 따라 구현.    

코드를 작성하기 전에 구현을 설계하면 어느정도 이점이 있음.   

#### 구현설계
스택을 구현할때는 push와 pop루틴이 필요.    
루틴을 클래스로 캡슐화하지 않는 경우를 가정할 때 각 함수에는 연산을 수행할 스택을 전달해야 한다.   
그리고 push 연산을 할때는 집어넣을 데이터를, pop 연산을 할때는 스택에서 꺼낸 데이터를 반환한다.    
    
**스택을 전달하는(넘겨주는) 가장 간단한 방법은 스택에 대한 포인터를 전달하는 것.**    
스택을 연결리스트로 구현할 것이므로, **리스트의 헤드에 대한 포인터를 스택에 대한 포인터**로 사용하면 된다.   
push 함수의 경우에는 스택에 대한 포인터 외에 **푸시할 데이터**를 두번째 매개 변수로 넘겨야 한다.    
pop 함수의 경우에는 스택에 대한 포인터만 인자로 받아들이면 되며, 스택에서 꺼낸 데이터를 반환해야 한다.   
     
**함수 원형을 만들기 위해서는 스택에 저장할 데이터형을 알아야 한다.**   
먼저, 적절한 데이터형으로 연결 리스트 구조체를 선언.    
인터뷰어가 특정 데이터형을 말하지 않는다면 그냥 void 포인터를 저장해서 일반적인 데이터형을 모두 커버하도록...   
다음과 같다.

<pre>
<code>
  typedef struct Element{
    struct Element *next;
    void *data; // void 포인터로 저장하여 범용적으로 사용. 
  }Element;

  void push(Element *stack, void *data); //스택에 대한 포인터와 전달할 데이터. 
  void *pop(Element *stack); // void* data를 반환하므로 data의 주소값 반환. 
</code>
</pre>
   
위 코드는 틀린 부분이 있을까...??    
먼저 두 연산 모두 리스트의 첫번째 원소를 변경하는 연산.   
이 함수를 호출하는 루틴의 스택 포인터를 변경해야 하는데, 이 *두 함수에 전달하는 포인터를 함수 내부에서 변경해 봤자 함수를 호출하는 쪽에서는 아무런 변화가 없다.*    
따라서 두 함수 모두 **스택에 대한 포인터를 가리키는 포인터**를 받도록 해야한다.   
   
다음과 같이 고쳐야한다.

<pre>
<code>
  void push(Element **stack, void *data);
  void *pop(Element **stack);
</code>
</pre>
   
이제 오류처리를 생각해보자.  
   
1. push의 오류처리.      
push 연산은 새로운 원소를 만들기 위해 동적으로 메모리를 할당해야 한다.   
메모리 할당은 언제나 실패할 수 있기 때문에 루틴을 작성할 때 **할당이 제대로 됐는지 확인하는 코드**를 넣어야 한다.   
그리고 push 함수를 호출하는 쪽에서 **연산이 성공적으로 수행되었는지 알아낼 수 있게 해주는 것**이 필요하다.   
  
  1) 메모리 할당이 제대로 됐는지 확인하는 코드.
  2) 연산이 성공적으로 수행됐는지 확인하는 코드. 
   
C 에서 어떤 루틴이 성공적으로 실행되었는지를 확인하는 가장 간편한 방법은 **반환 값**을 활용하는 방법.   
-> 루틴을 **if 선언문**의 조건문에서 실행하고, 본체에서는 오류를 처리하는 방법을 사용 가능.   
push 함수를 성공했을 때는 true를 실패했을 때는 false를 반환하도록 고치자.   
   
2. pop의 오류처리.   
pop은 메모리를 할당할 필요가 없지만 **비어있는 스택에 대해서 pop 연산을 한다면 어떻게 해야할까?**    
연산이 제대로 수행될 수 없다는 것을 알려줘야 하는데, 문제는 연산이 성공적으로 수행되었을때 데이터를 반환해야 한다는 점이다.   
C 함수에서는 반환 값의 개수가 하나로 제한되어 있지만, 지금 구현하고 있는 pop 함수는 사실 1)스택에서 꺼낸 데이터, 2) 오류 코드. 두가지를 반환해야 한다.   
    
여러가지 방법으로 해결할 수 있지만, 그 중에 만족스러운 해결책은 없다.  
한가지 방법은 반환 값 하나를 두가지 용도로 모두 사용하는 방법. - 팝 연산이 성공적으로 수행되면 데이터를, 아니면 NULL을 반환하는 방법.
데이터가 포인터 형이고 스택에 널 포인터를 저장할 일이 없다면 괜찮지만, **널 포인터도 저장할 수 있다면 실제로 저장한 값인지 비어있는지 구분할 수가 없다.**   
또 다른 방법은 절대로 올바른 데이터가 될 수 없는 특별한 값(예약되어 있는 메모리 블록에 대한 포인터)를 반환하는 방법. 
하지만, 반환 값을 데이터와 오류 코드로 동시에 활용할 수 없다고 가정하면 **결국 두개의 서로 다른 값을 반환해야 한다.**   
    
-> 스택 매개 변수를 처리하는 방법과 똑같은 방법을 떠올려보자. (어떤 변수에 대한 포인터를 전달하는 방법.)
    루틴에서 포인터를 써서 어떤 변수의 값을 바꾸고 호출한 쪽에서는 스택에 대해 팝 연산을 수행한 다음 그 값을 확인하는 것. 
   
두가지로 만들 수 있다. 
1. 오류 코드 변수에 대한 포인터를 인자로 받아들이고 데이터를 반환.
2. 반대로 데이터 변수에 대한 포인터를 인자로 받아오고 오류 코드를 반환.
   
보통은 1번 데이터를 반환하는 경우를 생각하지만, 오류 코드를 반환하지 않으면 pop연산이 복잡해진다.   
if 또는 while 선언문의 조건문 부분에서 pop 함수를 호출할 수 없고, 대신 오류코드를 받아오기 위한 변수를 선언한 다음에 pop 함수를 호출한 다음에 별도로 그 값을 확인해야 하기 때문이다.   
게다가 push는 데이터 인자를 받아들이고 오류 코드를 반환하는데, pop에서는 반대로 오류 코드를 인차로 처리하고 데이터를 반환하게 된다.   

따라서 다음과 같이 코드를 고칠 수 있다. 

<pre>
<code>
  void push(Element **stack, void *data);
  void pop(Element **stack, void **data);
</code>
</pre>

다시 push 연산에서는 새로운 원소를 할당하고, 메모리 할당 과정에서 문제가 없었는지 확인하고, 새로운 원소의 데이터를 설정하고, 스택의 맨 위에 놓은 스택 포인터를 조정한다.   
   
코드로 표현하면 다음과 같다.   

<pre>
<code>
  bool push(Element **stack, void *data){
    
    //새로운 원소 할당.
    Element *elem = new Element;
    //메모리 할당 과정에서 문제가 없는지 확인.
    if (!elem) return false;
    
    // 새로운 원소의 데이터를 설정.
    elem->data = data;
    // 스택의 맨위에 놓으 스택 포인터를 조정. 
    elem->next = *stack;
    *stack = elem;
    return true;
  };
</code>
<pre>
   
pop 연산에서는 스택이 비어있진 않은지 확인한 다음 맨 위에 있는 원소의 데이터를 가져오고 스택 포인터를 변경하고 더 이상 스택에 들어있지 않은 원소의 메모리 할당을 해제한다.   
   
코드로 표현하면 다음과 같다.   

<pre>
<code>
  bool pop(Element **stack, void **data){
      Element *next;
      while(*stack){
          next = (*stack)->next;
          delete *stack;
          *stack = next;
      }
      return true;
  };
</code>
</pre>
   
객체지향 언어를 사용한다면 인터페이스를 훨씬 더 깔끔하게 설계할 수 있을것. 















    

