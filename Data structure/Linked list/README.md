

[기초적인 연결리스트 연산](#기초적인-연결-리스트-연산)

[연결 리스트 문제](#연결-리스트-문제)   
[- 스택 구현법](#문제-1-스택-구현법)   
[- 테일 포인터](#문제-2-연결-리스트의-테일-포인터)   
[- 버그 찾기](#문제-3-removeHead의-버그)   
[- m번째 원소](#문제-4-연결리스트의-마지막에서-m번째-원소)   

    
---------------------------------------

# 개요   

연결 리스트(linked list)는 사실 워낙 간단해 보이지만 동적인 데이터를 처리하는 것과 관련된 수많은 문제의 근간을 이루는 자료구조.

효율적인 리스트 종주(traversal), 리스트 정렬, 리스트 앞이나 뒤쪽 끝에서의 삭제 또는 삽입에 대한 문제는 기초적인 자료구조 개념을 테스트하기에 더할 나위 없이 좋다. 리스트를 완벽하게 구현하는데 보통 10분이 채 걸리지 않기 때문에 문제를 푸는 시간은 충분하며 대조적으로 해시 테이블처럼 복잡한 자료구조는 구현하는 데만 많은 인터뷰 대부분의 시간을 차지한다.


* 연결 리스트의 종류  
  연결리스트는 3가지 유형으로 단일 연결 리스트(Singly-linked list), 이중 연결 리스트(doubly-linked list), 원형 연결 리스트(circularly-linked     lisat)이 존재한다.

인터뷰어가 "연결 리스트"라고만 말한다면 보통 단일 연결 리스트를 뜻함. 
단일 연결 리스트는 각각 다음 원소를 가리키는 next 포인터 또는 레퍼런스(연결 링크)가 들어있는 데이터 원소들로 구성된다.
리스트의 마지막 원소에는 빈 링크 또는 널 링크가 들어간다. 

  <pre>
  C이나 C++에서는 원소의 next포인터와 그 원소에 들어갈 데이터가 다음 코드에 있는 것처럼 하나로 묶여 있다. 

  <code>
    typedef struct intElement {
      struct intElement *next;
      int data;
    }intElement;
  </code>
  next 포인터를 구조체나 클래스 맨 앞 쪽에 넣어두면 그 원소에 어떤 데이터가 들어가든 제대로 동작하는 포괄적인 리스트 처리 루틴을 더 쉽게 만들 수 있다는 장점이 있다.
  </pre>
  
어떤 언어를 쓰든 단일 연결 리스트를 구현할 때는 몇가지 주의해야 할 특별 케이스 및 함정이 도사리고 있다.  
단일 연결 리스트의 연결 링크는 다음 원소를 가리키는 포인터(또는 레퍼런스)만으로 구성되기 때문에 리스트를 한 방향으로만 종주할 수 있다.  
__따라서 리스트를 완전히 종주하려면 반드시 첫 번째 원소부터 시작해야한다.__  
그래서 연결 리스트라는 용어를 어떤 연결 리스트의 첫 번째 원소라는 뜻으로 쓰는 경우도 종종 있다.   
   
*인터뷰어가 어떤 함수에서 인자로 연결 리스트를 받는다고 말하면, 그 연결리스트의 첫 번째 원소에 대한 포인터/레퍼런스를 인자로 받아들인다는 뜻으로 이해하면 된다.*

## 기초적인 연결 리스트 연산  

### 헤드 원소 추적
단일 연결 리스트에서는 반드시 헤드 원소를 추적해야 한다.  

<pre>
따라서 새로운 원소를 첫 번째 원소 앞에 추가한다거나 첫 번째 원소를 제거할 때 리스트의 헤드에 대한 포인터 또는 레퍼런스를 갱신해야 한다.
<code>
  bool insertInFront(intElement *head, int data){
    intElement *newElem = new intElement;
    if (!newElem) return false;
    
    newElem->data = data;
    head = newElem; // 틀렸음.
    return true;
}

</code>
</pre>


위 코드에서는 헤드 포인터에 대한 지역 변수 사본만을 갱신하기 때문에 이 코드는 제대로 작동하지 않는다. (함수 인자로 단일 포인터 사용.)   
제대로 작동하게 하려면 **헤드 포인터에 대한 포인터** 를 넘겨줘야 한다.
<pre>
<code>
  bool insertInFront(intElement **head, int data){
    intElement *newElem = new intElement;
    if (!newElem) return false;
    
    newElem->data = data;
    *head = newElem; // 더블 포인터를 사용하여 헤드의 주소를 갱신.
    return true;
}
</code>
</pre>

### 종주 

헤드 원소가 아닌 다른 리스트 원소를 가지고 작업을 해야하는 경우도 있다.  
연결 리스트의 첫 번째 원소가 아닌 원소에 대한 연산을 하려면 리스트에 있는 원소 중 일부를 종주해야 할 수도 있으며,   
   
*이때 항상 리스트가 끝나지 않는지 확인을 해야한다.*

<pre>
  아래에 있는 코드는 틀린 코드다. (java code)
<code>
  public intElement find(intElement head, Object data){
      while(head.data != data){
          head = head.next;
      }
      return head;
  }
</code>

리스트가 끝났는지 확인하기 위하여 head != null을 추가하여 리스트가 끝났는지 확인.

<code>
  public intElement find(intElement head, Object data){
    while(head != null && head.data != data){ 
        head = head.next;
    }
    return head;
  }
</code>
</pre>


### 원소의 삽입 및 삭제   

단일 연결 리스트에 있는 원소들은 다음 원소에 대한 링크를 통해서만 관리할 수 있기 때문에 중간에 있는 원소를 삽입 또는 삭제하려면, 그 앞 원소의 링크를 수정해야 한다.  
그리고 그 앞 원소를 알아낼 방법이 없기 때문에 **리스트를 종주해야 할 수 있다.**

<pre>
    리스트의 헤드 부분을 처리할 때는 한층 더 주의를 기울여야한다.
<code>
    bool deleteElement(intElement **head, intElement *deleteme){
      intElement *elem = *head;

      if (deleteme == *head) {
          *head = elem->next;
          delete deleteme;
          return true;
      }

      while(elem) {
          if(elem->next == deleteme){
              elem->next = deleteme->next;
              delete deleteme;
              return true;
          }
          elem = elem -> next;
      }
      // *deletme 가 없는 경우*
      return false;
  }
</code>

삭제 및 삽입을 하려면 삭제 및 삽입할 위치의 바로 앞에 있는 원소에 대한 포인터 or 레퍼런스가 필요.

</pre>

*한가지 더 신경 써야 할 문제.*    
   
연결 리스트에 있는 모든 원소를 삭제하고자 하는 경우.   
가장 쉽게 생각할 수 있는건 포인터 1개를 사용하여 리스트를 종주하면서 원소들을 하나씩 제거하는 방법.  
**BUT,** 실제로 구현하려고 하면 문제가 생김.   
다음 포인터로 넘어가는 작업과 원소를 제거하는 작업 중 어느 것을 먼저 해야할까?   
1. 다음 포인터로 넘어가는 일을 먼저 하면 제거해야할 원소의 포인터를 덮어쓴 상황이기 때문에 메모리 할당을 해제할 수가 없다.   
2. 제거를 먼저 해버리고 나면 방금 제거한 원소에 next 포인터가 사라져 다음 원소로 넘어가는 것이 불가능하다.   
     
<pre>
따라서, 다음 코드처럼 포인터를 2개 써야한다. 
<code>
    void deleteList(intElement **head){
      intElement *deleteme = *head;

      while(deleteme){
          intElement *next = deleteme->next;
          delete  deleteme;
          deleteme = next;
      }

      *head = NULL;
  }
</code>
</pre>

원소를 삭제할 때는 적어도 두 개의 포인터 변수가 필요.   
삽입할 때도 포인터 변수가 두 개 있어야 하는 것은 마찬가지지지만, 둘 중 하나는 리스트에 있는 원소를 위해 쓰이고, 다른 하나는 메모리 할당에 의해 반환되는 포인터용으로 쓰이기 때문에 삽입 연산에서 포인터를 한 개만 쓰는 실수를 범하는 일은 거의 없다. 


## 연결 리스트 문제   

인터뷰에서 접하게 될 만한 대표적인 연결 리스트 문제를 몇 가지 소개하자면 다음과 같다.   
 
    
### 문제 1 스택 구현법
<pre>
스택 자료 구조에 대해 논하라. 연결 리스트 또는 동적 배열(dynamic array)을 써서 C로 스택을 구현해 보고, 그 자료구조를 사용한 이유를 설명하라.   
완전하고 일관적이고 사용하기 편린한 스택 인터페이스를 설계하라.   
</pre>   

#### 문제 해석    

이 문제는 세가지를 중점적으로 살펴보기 위한 문제.    
    
    1. 기본적인 자료구조에 대한 지식
    2. 자료구조를 조작하기 위한 루틴을 만드는 능력
    3. 일련의 루틴에 대한 일관적인 인터페이스를 설계하는 능력
    
스택은 후입선출(LIFO, last-in-first-out) 자료구조로 원소는 들어간 순서와 반대 순서로 나온다.   
원소를 삽입하고 삭제하는 연산은 각각 Push, Pop.    
스택은 여러 개의 서브테스크로 나뉘는 테스크를 관리하는데 유용하게 쓰이는 자료구조.   
     
     
스택을 구현하는 방법으로 먼저 **동적 배열**을 사용할 수 있다.    
연결리스트에 대한 상대적인 장점은 **배열 원소에 대한 임의 접근**이 가능하다는 점(인덱스만 알면 즉시 접근 가능).    
하지만, 스택의 연산은 한 방향으로만 이루어지기 때문에 이 장점은 쓸모 없다.   
그리고, 동적배열이 커짐에 따라 배열의 크기를 조절해야 하고 그 과정에서 기존 배열의 모든 원소들을 옮겨야 하므로 시간이 오래 걸림.    
     
반대로 **연결리스트**에서는 각 원소마다 메모리를 동적으로 할당하며, 크기가 작은 원소를 다룰 때는 그에 따른 오버헤드 주의.     
특히 적당한 크기의 동적 배열을 사용하여 배열 크기를 자주 조절하지 않아도 되는 경우와 비교하면 속도가 많이 떨어질 수도 있다.    
* 일반적으로 동적 배열을 기반 스택이 연결리스트 기반 스택에 비하여 대체로 빠른편.   
    
인터뷰에서는 각각의 장단점을 설명하고 선호도에 따라 구현.    

코드를 작성하기 전에 구현을 설계하면 어느정도 이점이 있음.   

#### 구현설계
스택을 구현할때는 push와 pop루틴이 필요.    
루틴을 클래스로 캡슐화하지 않는 경우를 가정할 때 각 함수에는 연산을 수행할 스택을 전달해야 한다.   
그리고 push 연산을 할때는 집어넣을 데이터를, pop 연산을 할때는 스택에서 꺼낸 데이터를 반환한다.    
    
**스택을 전달하는(넘겨주는) 가장 간단한 방법은 스택에 대한 포인터를 전달하는 것.**    
스택을 연결리스트로 구현할 것이므로, **리스트의 헤드에 대한 포인터를 스택에 대한 포인터**로 사용하면 된다.   
push 함수의 경우에는 스택에 대한 포인터 외에 **푸시할 데이터**를 두번째 매개 변수로 넘겨야 한다.    
pop 함수의 경우에는 스택에 대한 포인터만 인자로 받아들이면 되며, 스택에서 꺼낸 데이터를 반환해야 한다.   
     
**함수 원형을 만들기 위해서는 스택에 저장할 데이터형을 알아야 한다.**   
먼저, 적절한 데이터형으로 연결 리스트 구조체를 선언.    
인터뷰어가 특정 데이터형을 말하지 않는다면 그냥 void 포인터를 저장해서 일반적인 데이터형을 모두 커버하도록...   
다음과 같다.

<pre>
<code>
  typedef struct Element{
    struct Element *next;
    void *data; // void 포인터로 저장하여 범용적으로 사용. 
  }Element;

  void push(Element *stack, void *data); //스택에 대한 포인터와 전달할 데이터. 
  void *pop(Element *stack); // void* data를 반환하므로 data의 주소값 반환. 
</code>
</pre>
   
위 코드는 틀린 부분이 있을까...??    
먼저 두 연산 모두 리스트의 첫번째 원소를 변경하는 연산.   
이 함수를 호출하는 루틴의 스택 포인터를 변경해야 하는데, 이 *두 함수에 전달하는 포인터를 함수 내부에서 변경해 봤자 함수를 호출하는 쪽에서는 아무런 변화가 없다.*    
따라서 두 함수 모두 **스택에 대한 포인터를 가리키는 포인터**를 받도록 해야한다.   
   
다음과 같이 고쳐야한다.

<pre>
<code>
  void push(Element **stack, void *data);
  void *pop(Element **stack);
</code>
</pre>
   
이제 오류처리를 생각해보자.  
   
1. push의 오류처리.      
push 연산은 새로운 원소를 만들기 위해 동적으로 메모리를 할당해야 한다.   
메모리 할당은 언제나 실패할 수 있기 때문에 루틴을 작성할 때 **할당이 제대로 됐는지 확인하는 코드**를 넣어야 한다.   
그리고 push 함수를 호출하는 쪽에서 **연산이 성공적으로 수행되었는지 알아낼 수 있게 해주는 것**이 필요하다.   
  
  1) 메모리 할당이 제대로 됐는지 확인하는 코드.
  2) 연산이 성공적으로 수행됐는지 확인하는 코드. 
   
C 에서 어떤 루틴이 성공적으로 실행되었는지를 확인하는 가장 간편한 방법은 **반환 값**을 활용하는 방법.   
-> 루틴을 **if 선언문**의 조건문에서 실행하고, 본체에서는 오류를 처리하는 방법을 사용 가능.   
push 함수를 성공했을 때는 true를 실패했을 때는 false를 반환하도록 고치자.   
   
2. pop의 오류처리.   
pop은 메모리를 할당할 필요가 없지만 **비어있는 스택에 대해서 pop 연산을 한다면 어떻게 해야할까?**    
연산이 제대로 수행될 수 없다는 것을 알려줘야 하는데, 문제는 연산이 성공적으로 수행되었을때 데이터를 반환해야 한다는 점이다.   
C 함수에서는 반환 값의 개수가 하나로 제한되어 있지만, 지금 구현하고 있는 pop 함수는 사실 1)스택에서 꺼낸 데이터, 2) 오류 코드. 두가지를 반환해야 한다.   
    
여러가지 방법으로 해결할 수 있지만, 그 중에 만족스러운 해결책은 없다.  
한가지 방법은 반환 값 하나를 두가지 용도로 모두 사용하는 방법. - 팝 연산이 성공적으로 수행되면 데이터를, 아니면 NULL을 반환하는 방법.
데이터가 포인터 형이고 스택에 널 포인터를 저장할 일이 없다면 괜찮지만, **널 포인터도 저장할 수 있다면 실제로 저장한 값인지 비어있는지 구분할 수가 없다.**   
또 다른 방법은 절대로 올바른 데이터가 될 수 없는 특별한 값(예약되어 있는 메모리 블록에 대한 포인터)를 반환하는 방법. 
하지만, 반환 값을 데이터와 오류 코드로 동시에 활용할 수 없다고 가정하면 **결국 두개의 서로 다른 값을 반환해야 한다.**   
    
-> 스택 매개 변수를 처리하는 방법과 똑같은 방법을 떠올려보자. (어떤 변수에 대한 포인터를 전달하는 방법.)
    루틴에서 포인터를 써서 어떤 변수의 값을 바꾸고 호출한 쪽에서는 스택에 대해 팝 연산을 수행한 다음 그 값을 확인하는 것. 
   
두가지로 만들 수 있다. 
1. 오류 코드 변수에 대한 포인터를 인자로 받아들이고 데이터를 반환.
2. 반대로 데이터 변수에 대한 포인터를 인자로 받아오고 오류 코드를 반환.
   
보통은 1번 데이터를 반환하는 경우를 생각하지만, 오류 코드를 반환하지 않으면 pop연산이 복잡해진다.   
if 또는 while 선언문의 조건문 부분에서 pop 함수를 호출할 수 없고, 대신 오류코드를 받아오기 위한 변수를 선언한 다음에 pop 함수를 호출한 다음에 별도로 그 값을 확인해야 하기 때문이다.   
게다가 push는 데이터 인자를 받아들이고 오류 코드를 반환하는데, pop에서는 반대로 오류 코드를 인차로 처리하고 데이터를 반환하게 된다.   

따라서 다음과 같이 코드를 고칠 수 있다. 

<pre>
<code>
  void push(Element **stack, void *data);
  void pop(Element **stack, void **data);
</code>
</pre>

다시 push 연산에서는 새로운 원소를 할당하고, 메모리 할당 과정에서 문제가 없었는지 확인하고, 새로운 원소의 데이터를 설정하고, 스택의 맨 위에 놓은 스택 포인터를 조정한다.   
   
코드로 표현하면 다음과 같다.   

<pre>
<code>
  bool push(Element **stack, void *data){
    
    //새로운 원소 할당.
    Element *elem = new Element;
    //메모리 할당 과정에서 문제가 없는지 확인.
    if (!elem) return false;
    
    // 새로운 원소의 데이터를 설정.
    elem->data = data;
    // 스택의 맨위에 놓으 스택 포인터를 조정. 
    elem->next = *stack;
    *stack = elem;
    return true;
  };
</code>
</pre>
   
pop 연산에서는 스택이 비어있진 않은지 확인한 다음 맨 위에 있는 원소의 데이터를 가져오고 스택 포인터를 변경하고 더 이상 스택에 들어있지 않은 원소의 메모리 할당을 해제한다.   
   
코드로 표현하면 다음과 같다.   

<pre>
<code>
  bool pop(Element **stack, void **data){
      Element *elem = *stack;
      
      if(!(elem=*stack)) return false;
      
      *data = elem->data;
      *stack = elem->next;
      delete elem;
      return true; 
  };
</code>
</pre>
   
객체지향 언어를 사용한다면 인터페이스를 훨씬 더 깔끔하게 설계할 수 있을것. 
   
꼭 필요한건 아니지만 createStack과 deleteStack 함수도 만들어 두면 좋다.   
이런 함수를 만들지 않고 스택을 지울 때는 스택이 텅 비게 될 때까지 pop을 계속 호출하고, 스택을 만들 때는 스택 인자로 널 포인터를 넘겨주면서 push 함수를 호출하는 방법을 쓸 수도 있다.   
하지만 스택을 만들고 지우기 위한 함수를 따로 만들어 주면 스택의 구현 방법과는 무관하게 사용할 수 있는 완전한 인터페이스를 구축할 수 있다.   
동적 배열을 써서 스택을 구현할 때는 createStack/deleteStack 함수를 꼭 만들어야 할 가능성이 높다.   
따라서 이런 함수들을 포함시키면 스택을 사용하는 프로그램 자체를 건드리지 않고 스택 인터페이스를 만들수 있다.   

createStack, deleteStack 모두 이전의 함수들과 동일한 인자로 통일시키기 위하여 스택의 포인터의 포인터를 넘겨준다.


<pre>
    구현은 간단하다.
<code>
    bool createStack(Element **stack){
        *stack = NULL;
        return true;
    }
</code>
</pre>
    
deleteStack에서 pop 함수를 여러 번 호출해도 되겠지만, 그냥 연결 리스트를 종주하면서 각각을 쭉 비워줘도 된다.   
*현재 원소를 지울 때 다음 원소의 주소(현재 원소에 저장되어 있는)를 저장하기 위한 임시 포인터가 필요하다는 점에 주의. 

<pre>
<code>
    bool deleteStack(Element **stack){
        Element *next;

        while (*stack) {
            next = (*stack)->next;
            delete *stack;
            *stack = next;
        }
        return true;
    }
</code>
</pre>


    
### 문제 2 연결 리스트의 테일 포인터
<pre>
정수를 저장하기 위한 어떤 단일 연결 리스트의 첫 번째와 마지막 원소를 가리키는 head와 tail이라는 전역 포인터가 있다.    
다음과 같은 함수 원형에 대한 C 함수를 구현하라.

<code>
    bool remove( Element *elem );
    bool insertAfter( Element *elem, int data );
</code>
   
remove 함수의 인자는 삭제할 원소다. insertAfter 함수의 두 인자는 각각 새로 추가는 원소의 바로 앞 원소에 대한 포인터와 새로 추가될 원소의 데이터이다.   
insertAfter 함수를 호출할 때 NULL을 넘겨주는 방식으로 리트스의 맨 앞에도 새 원소를 추가할 수 있어야 한다.   
함수가 성공적으로 실행되면 true를. 그렇지 않으면 false를 반환한다.   
head 와 tail 포인터는 항상 올바른 값으로 유지해야 한다.   
</pre>   
   
   
비교적 간단한 문제.  
테일 포인터 관리만 추가하면 되며, 새로운 알고리즘을 설계할 필요는 없다.   
   
이 포인터는 언제 바꿔줘야 할까?   
중간에서 작업을 할때는 head와 tail에 영향을 미치지 않는다. head 와 tail 포인터는 리스트의 맨 앞, 또는 맨 뒤에 있는 원소가 바뀔 때만 바꿔주면 된다.  
자세하게 말하자면 맨 앞이나 맨 뒤에 원소를 추가하게 되면 추가된 원소가 맨 앞, 맨 뒤에 있는 원소가 된다.   
그리고 맨 앞이나 맨 뒤에 있는 원소를 삭제하면 맨 앞에서 2번째, 맨 뒤에서 2번째 원소가 첫 번째 또는 마지막 원소로 바뀐다.   
   ㅈ 앞 
맨 앞 또는 맨 뒤에서 원소를 삽입/삭제하는 *특별케이스* 말고 또 다른 특별케이스를 생각해보자.   
    1) NULL 포인터 인자가 들어오는 상황.   
    2) 리스트 길이 때문에 문제가 생기는 상황.   
   
비어있는 리스트에는 아무 원소도 없기 때문에 맨 앞, 중간, 맨 뒤에 있는 원소를 따지는 것이 무의미하다.   
구현한 알고리즘이 길이 0,1,2인 리스트의 경우에도 정확하게 작동하는지 확인해봐야 한다.   
   
remove 함수를 만들어본다.   
*특별 케이스* : 앞에서 첫 번째 원소를 삭제하는 것 - 삭제할 원소를 head와 비교해서 그 경우를 처리해야 하는지 확인하면 된다.   
   
<pre>
<code>
    bool remove(Element *elem){
        if (elem == head){
            head = elem -> next;
            delete elem;
            return true; 
        }
    }
</code>
</pre>

이제 일반적인 경우에 속하는 원소가 중간이 있는 경우의 코드를 만들어보자. 
*일반 케이스* : 삭제하려는 원소가 중간에 있는 경우.   
리스트에서의 현재 위치를 파악하기 위하여 원소에 대한 포인터(curPos)가 필요.   
연결 리스트에서 원소를 삭제할 떄는 앞에 있는 원소의 next 포인터를 변경하기 위하여 앞에 있는 원소에 대한 포인터도 필요하다는 것을 잊지 말자.   
앞에 있는 원소를 찾아내는 가장 쉬운 방법은 curPos->next 와 elem 을 비교하는 것이다. (반복문을 만들 때 어떤 원소도 빼먹지 않도록 해야한다.)   
어차피 첫번째 원소를 특별 케이스로 처리하기 때문에 두번째 원소에서 시작해도 상관없지만, curPos를 다음 원소로 넘기기전에 반드시 curPos->next와 elem 을 비교하는 작업을 수행해야 한다.   
그렇지 않으면 두번째 원소를 그냥 지나칠 수 있기 때문.   ㅊ

<pre>
<code>

    bool remove(Element *elem){
        //중간 원소 처리를 위하여 현재 위치 저장.
        Element *curpos = head;

        if (elem == head){
            head = elem -> next;
            delete elem;
            return true;
        }

        //중간 원소 처리.  
        while(curpos){
            if(curpos->next == elem){
                curpos->next = elem->next;
                delete elem;
                return true;
            }
            curpos = curpos ->next;
        }
        return false;
    }
    
</code>
</pre>
   
이제 마지막 원소를 처리하는 케이스.   
마지막 원소의 next 포인터는 NULL 이다.   
이 원소를 삭제할 때는 마지막에서 두번째 원소의 next 포인터를 NULL로 바꾸고, 마지막 원소를 제거하면 된다.   
앞서 중간 원소를 삭제하기 위한 코드로 마지막 원소도 삭제할 수 있으며, 마지막 원소를 삭제할 때는 tail 포인터를 변경만 해주면 된다.   
curpos->next가 NULL이면 리스트의 마지막 원소를 변경한 것이므로 tail 포인터도 바꿔줘야 한다. 
   
다음과 같다.
<pre>
<code>
    bool remove(Element *elem){
        Element *curpos = head;

        if (elem == head){
            head = elem -> next;
            delete elem;
            return true;
        }

        while(curpos){
            if(curpos->next == elem){
                curpos->next = elem->next;
                delete elem;

                // tail 처리해주는 부분.
                if(curpos->next == NULL)
                    tail = curpos;
                return true;
            }
            curpos = curpos ->next;
        }
        return false;
    }
</pre>
</code>
   
이제 특별 케이스로 NULL 포인터가 들어왔을때와 길이가 0,1,2인 리스트일때를 생각해보자.   
   
가장 간단한 해결책은 elem이 NULL이면 false를 반환하는 것이다.   
리스트의 길이가 0이면 NULL로 앞서 선언한 조건문에서 해결가능.   
   
리스트의 길이가 1이면 head와 tail 모두 하나뿐인 원소를 가리키고, 이 원소가 삭제할 수 있는 유일한 원소이다.   
elem == head 가 참이고, elem->next == NULL이면 head가 NULL로 설정되고 그 원소가 메모리에서 제거된다.   
하지만 tail은 여전히 제거된 원소(head의 주소)를 가리키게 된다.   
**따라서 원소가 한개인 경우에는 tail을 NULL로 바꿔주는 처리를 따로 해줘야한다.**   
   
리스트의 길이가 2이면 첫번째 원소를 삭제하면 head가 두번째 원소가 되고, 두번째 원소를 삭제하면 tail이 첫번째 원소가 된다.   
가운데 원소가 없다고 해서 딱히 문제될 일이 없다.   
   
**따라서, NULL 포인터와 리스트의 길이가 1인 경우만 특별히 처리해주면 된다.**   

<pre>
<code>

    bool remove(Element *elem){
        Element *curpos = head;

        // NULL 포인터가 들어왔을시.
        if(!elem)
            return false;

        if (elem == head){
            head = elem -> next;
            delete elem;
            // 리스트의 길이가 1인 경우.
            if(head ==NULL){
                tail = NULL;
            }
            return true;
        }

        while(curpos){
            if(curpos->next == elem){
                curpos->next = elem->next;
                delete elem;

                // tail 처리해주는 부분.
                if(curpos->next == NULL)
                    tail = curpos;
                return true;
            }
            curpos = curpos ->next;
        }
        return false;
    }

</pre>
</code>
   
insertAfter를 코딩할 때도 비슷한 식으로 하면 된다.    
새로운 원소를 할당해야하므로 새로운 원소가 메모리 할당이 제대로 됐는지 확인하고, 메모리 누설이 생기지 않는지도 확인해야한다.   
delete의 특별케이스와 전반적으로 매우 유사.


<pre>
<code>
    bool insertAfter(Element *elem, int data){
        Element *newElem, *curpos = head;

        newElem = new Element;

        if(!newElem)
            return false;
        newElem->data = data;

        // 리스트의 맨 앞에 삽입하는 경우.
        if(!elem){
            elem->next = head;
            head = newElem;

            // 비어있는 리스트에 삽입하는 경우.
            if(!tail){
                tail = newElem;
            }
            return true;
        }

        // 일반적인 경우.
        while(curpos){
            if(curpos == elem){
                newElem->next = curpos->next;
                curpos->next = newElem;

                // 리스트 맨 뒤에 추가하는 경우.
                if(!(newElem->next)){
                    tail = newElem;
                }
                return true;
            }
            curpos = curpos->next;
        }

        // 삽입할 위치를 찾지 못할경우 메모리 할당 해제. 
        delete newElem;
        return false;
    }
    
</code>
</pre>

-------------------------

### 문제 3 removeHead의 버그

<pre>
    단일 연결 리스트에서 맨 앞에 있는 원소를 제거하기 위한 용도로 만들어진 다음의 C/C++ 함수에 있는 버그를 찾아내어 수정하라.
    
    <code>
    
    void removeHead(Node *head){
        delete head;        // 첫째줄
        head = head->next;  // 둘째줄
    }
    </code>
</pre>
   
버그를 찾아내는 문제도 드물지 않게 나오는 편.   
실제 프로그래밍을 할때 전략과 조금 다른 전략을 이용.   

    1. 데이터가 함수에 제대로 들어오는지 확인.
        없는 변수를 쓰려고 한다거나 long이어야 하는 것을 int로 읽으려고 한다거나 하는 문제가 없는지 확인하고, 작업을 수행하는데 필요한 모든 값들이 준비되어 있는지 살펴본다.
    
    2. 함수의 각 줄이 제대로 작동하는지 확인.
        각 줄에서 그 작업이 올바르게 실행되는지, 의도된 결과가 만들어지는지 확인. 
    
    3. 함수에 데이터가 올바르게 나오는지 확인. 
        예상되는 결과가 반환 값으로 돌아가야 한다. 그리고 함수에서 호출한 쪽의 변수를 갱신해야 한다면 그 작업이 제대로 이뤄지는지도 확인.
    
    4. 흔히 발생하는 오류 조건을 확인.
        오류 조건은 문제에서 주어진 요구사항에 따라 다양하게 달라질 수 있다. 
        오류는 주로 특이한 인자 값과 연관되어 발생.    
        ex) 자료구조를 다룰때 비어있는 자료구를 다룰때 문제가 생기는 경우가 많다. 
    
우선 첫번째 단계부터 시작.   
    연결리스트라면 헤드 포인터만 들어오면 모든 노드에 접근 가능. 
    여기선 Node \*head가 주어지기 떄문에 모든 노드에 접근이 가능하므로 문제가 없다.
    
두번째 단계로 함수를 한 줄씩 분석해보자. 
    첫째 줄에서는 head를 메모리에서 제거하며 여기까진 문제가 없다.
    둘째 줄에서는 head에 새로운 값을 대입하는데 여기서 기존의 head 값을 사용한다. 여기서 문제 발생. 
    이미 head를 지워버렸기 때문에 둘째 줄에서 비워버린 메모리를 참조하는 셈. 
    
    -> head를 제거하면서 그 변수가 제거된 후에도 next 값은 써먹어야 한다. 
       임시 변수를 서서 head의 next 값을 따로 저장해두면 이 문제를 해결할 수 있다.
       그런 후 head를 메모리에서 제거하고 임시 변수를 써서 head를 갱신하면 된다.
    
 결과적으로 코드는 이런식으로 되어야 한다.
    
 <pre>
 <code>
    void removeHead(Node *head)
        Node *temp = head->next;
        delete head;
        head = temp;
    }
</code>
</pre>
   
이제 세번째 단게로 가서 올바른 값을 반환하는지 살펴보자.   
    이 함수에선 void로 명시적인 반환 값은 없지만 head의 주소를 함수 내에서 변경해야하는 암묵적인 반환 값이 있다.   
    C에서는 모든 함수의 매개 변수가 값으로 전달되기 때문에 함수에는 각 인자의 사본 형태의 지역 변수만을 건드리게 되고, 그 사본을 바꿔봤자 함수 밖에서는 아무런 영향을 끼칠 수가 없다.
    
따라서, 다음과 같이 코드를 수정해야만 한다.

<pre>
<code>
    void removeHead(Node **head){
        Node *temp = (*head)->next;
        delete *head;
        *head = temp;
    }
</code>
</pre>   
   
이제 네번째 단계로 넘어가서 오류 조건을 체크해 보자.   
원소가 하나밖에 없는 리스트와 하나도 없는 리스트를 확인해보자.   
하나뿐인 리스트의 경우에는 하나뿐인 원소를 삭제하고 NULL를 반환하여 제대로 작동한다.   
반면에, 하나도 없는 리스트 (NULL 포인터)일 경우에는 첫번째 줄에서 NULL을 디레퍼런스하는 문제가 생긴다.   
이 문제를 해결하려면 첫번째 줄에서 head가 NULL인지 체크해줘야한다.   
    
수정한 코드는 다음과 같다.   
   
<pre>
<code>
    void removeHead(Node **head){
        Node *temp;
        if(!(*head)){
            temp = (*head)->next;
            delete *head;
            *head = temp;
        }
    }
</code>
</pre>   
  
지금까지 함수가 제대로 동작하는지, 올바르게 호출되고 제대로 된 값을 돌려주는지, 오류 조건을 확실히 처리했는지를 체크했다. 
   
--------------------------------    

### 문제 4 연결리스트의 마지막에서 m번째 원소   
   
<pre>
    단인 연결리스트가 주어졌을때 리스트의 맨 뒤에서 m번째 원소를 찾는 알고리즘을 만들어 보라.   
    이때 시간 및 공간 효율을 모두 고려해야한다.   
    오류조건의 처리에 주의하여 알고리즘을 구현하라.   
    여기에서 "맨 뒤에서 m번째 원소"는 m=0이면 리스트의 마지막 원소를 반환하는 식으로 생각한다.
</pre>
  
단일 연결 리스트는 앞 방향으로만 종주하기 때문에 맨 앞에서부터 m번째 원소를 찾는 것은 정말 쉽다.   
하지만 이 문제는 뒤에서부터 특정 위치에 있는 원소를 찾아야 한다.   
리스트를 종주하는 동안에는 끝이 어딘지 알 수가 없고, 끝을 찾고 나면 주어진 수만큼 앞으로 되돌아갈 방법이 마땅치가 않다.   
   
뒤에서 m번째를 찾는 일을 자주해야 한다면 단일 연결리스트가 아니라 다른 자료구조를 쓰는게 효율적.   

여러가지 방법이 존재.
우리가 찾아야 하는 것은 리스트의 끝으로부터 m번째 원소.    
    
    1. 어떤 원소로부터 m개만큼 뒤로 이동했을 때 리스트의 마지막 원소라면 우리가 찾는 m번째 원소다.   
    이동할때마다 원소를 확인하고 저장한다면 같은 원소를 여러번 지나가야 하기 때문에 별로 효율이 좋지 않다.     
    자세히 분석해보면 리스트에 있는 거의 모든 원소를 m번 지나야 한다.  
    리스트이 길이가 n이라면 이 알고리즘의 실행시간은 O(mn)이 된다.   
    
    2. 리스트를 종주하면서 원소들(또는 포인터나 레퍼런스)를 별도로 저장하면 어떻게 될까?   
    리스트의 끝에 도달했을떄, 저장해 둔 곳의 m번째 앞에 있는 원소를 찾아낼 수 있을 것이다.   
    임시 데이터를 저장할 자료 구조만 잘 선택하면 리스트를 한번만 종주하면 되기 때문에 O(n) 알고리즘을 만들 수 있다.      
    하지만, 이 알고리즘도 m이 커지게 되면 임시 데이터가 차지하는 공간이 커지기 떄문에 공간 효율이 좋지 않다.   
    
    3. 맨 뒤에서 앞으로 돌아가는 방식이 아닌 맨 앞에서부터 세어나가는 방법도 존재.   
    우리가 찾는 것은 뒤에서부터 m번째 원소이고, 그 원소가 앞에서부터 l번째 원소라고 하면 l+m=n 이다.   
    따라서 먼저 리스트의 개수 n을 구하고, l=m-n 을 통하여 l을 구한다음 접근 할 수 있다.   
    이렇게 하면 리스트를 두 번 종주해야 하며 여전히 O(n)이지만, 공간 효율이 좋아진다.   
    
    이렇게 리스트의 길이를 구해야 한다면 연결 리스트 전체를 두번은 종주해야 한다.    
    그렇다면 한번만 종주하여 원소를 찾아내는 방법은 없을까?   
       
    두개의 포인터로 하나는 현재 위치를 가리키는 포인터, 다른 하나는 그보다 m개 만큼 뒤에 있는 포인터를 선언한다.   
    보조를 맞춰서 두개의 포인터를 전진시킨다.   
    
    이때 어떤 오류조건을 따져봐야 하느냐?   
    만약 리스트에 있는 원소의 개수가 m개보다 작으면 m번째 원소가 존재하는 것이 불가능하다.   
    따라서 처음에 m개의 원소를 지날때 리스트가 끝나는지 확인할 필요가 있다.   
    
    알고리즘을 구현해보자.
    
<pre>
<code>
    Element *findMToLastElement(Element *head, int m){
        Element *current, *mbehind;
        int i;

        current = head;

        // 시작 위치에서부터 먼저 m만큼 앞으로 나가게 한다.
        for (i=0; i<m; i++){
            if(current->next){
                current = current->next;
            }else{
                return NULL;
            }
        }

        // 끝에 도달했을때 m앞에 있어야할 포인터.
        mbehind = head;

        // current 포인터가 리스트의 끝에 도달할때까지 계속 갱신한다. 
        while (current->next) {
            current = current->next;
            mbehind = mbehind->next;
        }
        return mbehind;
    }
</code>
</pre>


