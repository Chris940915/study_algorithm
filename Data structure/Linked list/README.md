연결 리스트(linked list)는 사실 워낙 간단해 보이지만 동적인 데이터를 처리하는 것과 관련된 수많은 문제의 근간을 이루는 자료구조.

효율적인 리스트 종주(traversal), 리스트 정렬, 리스트 앞이나 뒤쪽 끝에서의 삭제 또는 삽입에 대한 문제는 기초적인 자료구조 개념을 테스트하기에 더할 나위 없이 좋다. 리스트를 완벽하게 구현하는데 보통 10분이 채 걸리지 않기 때문에 문제를 푸는 시간은 충분하며 대조적으로 해시 테이블처럼 복잡한 자료구조는 구현하는 데만 많은 인터뷰 대부분의 시간을 차지한다.


* 연결 리스트의 종류 
연결리스트는 3가지 유형으로 단일 연결 리스트(Singly-linked list), 이중 연결 리스트(doubly-linked list), 원형 연결 리스트(circularly-linked lisat)이 존재한다.

인터뷰어가 "연결 리스트"라고만 말한다면 보통 단일 연결 리스트를 뜻함. 
단일 연결 리스트는 각각 다음 원소를 가리키는 next 포인터 또는 레퍼런스(연결 링크)가 들어있는 데이터 원소들로 구성된다.
리스트의 마지막 원소에는 빈 링크 또는 널 링크가 들어간다. 

  <pre>
  C이나 C++에서는 원소의 next포인터와 그 원소에 들어갈 데이터가 다음 코드에 있는 것처럼 하나로 묶여 있다. 

  <code>
    struct intElement {
      struct intElement *next;
      int data;
    };
  </code>
  next 포인터를 구조체나 클래스 맨 앞 쪽에 넣어두면 그 원소에 어떤 데이터가 들어가든 제대로 동작하는 포괄적인 리스트 처리 루틴을 더 쉽게 만들 수 있다는 장점이 있다.
  </pre>
  
어떤 언어를 쓰든 단일 연결 리스트를 구현할 때는 몇가지 주의해야 할 특별 케이스 및 함정이 도사리고 있다.  
단일 연결 리스트의 연결 링크는 다음 원소를 가리키는 포인터(또는 레퍼런스)만으로 구성되기 때문에 리스트를 한 방향으로만 종주할 수 있다.  
__따라서 리스트를 완전히 종주하려면 반드시 첫 번째 원소부터 시작해야한다.__  
그래서 연결 리스트라는 용어를 어떤 연결 리스트의 첫 번째 원소라는 뜻으로 쓰는 경우도 종종 있다.   
*인터뷰어가 어떤 함수에서 인자로 연결 리스트를 받는다고 말하면, 그 연결리스트의 첫 번째 원소에 대한 포인터/레퍼런스를 인자로 받아들인다는 뜻으로 이해하면 된다.*



