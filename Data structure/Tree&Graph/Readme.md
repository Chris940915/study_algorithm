[트리](#트리)   
[이진 트리](#이진-트리)   
[이진 검색 트리](#이진-검색-트리)   
[ -룩업](#룩업(Lookup))   
    
---------------------------------------
   
트리와 그래프는 프로그래밍에서 흔히 쓰이는 자료구조이기 때문에 프로그래밍 인터뷰에도 자주 등장한다.   
그 중에서도 트리는 지원자의 재귀 호출과 실행 시간 분석에 관한 지식을 테스트하기에 안성맞춤.   
게다가 트리는 간단한 편이여서 인터뷰를 진행하는 비교적 짧은 시간 동안 구현하기에도 적당하다.   
그래프 문제도 흥미롭긴 하지만 대체로 너무 복잡한 편이어서 인터뷰용 문제로 쓰기에는 안좋다.   
이런 이유 때문에 이 장에서는 주로 트리에 초점을 맞춘다.     
C# 이나 자바 같은 현대적인 언어를 사용해보자.   

# 트리   
   
## 개요   
   
트리는 0개 이상의 다른 노드에 대한 레퍼런스가 들어있는 노드(데이터 원소)로 구성된다.   
한 노드를 참조하는 노드는 하나뿐이다.   
연결리스트와 마찬가지로 노드도 구조체 또는 클래스로 표현되며, 트리는 포인터 또는 레퍼런스만 있다면 어떤 언어로든 구현할 수 있다.   
  
객체지향 언어에서는 보통 노드의 공통적인 부분을 하나의 클래스로 정의하고, 노드에 들어가는 데이터를 위해 서브클래스를 만들어서 사용한다.     
예를 들어, 정수가 저장되는 트리를 만들고 싶다면 다음과 같은 클래스를 사용하면 된다. 

<pre>
<code>
    public abstract class Node{
        private Node[] children;

        public Node(Node[] children){
            this.children = children;
        }

        public int getNumChildren(){
            return children.length;
        }

        public Node getChild(int index){
            return children[index];
        }
    }

    class IntNode extends Node {
        private int value;

        public IntNode(Node[] children, int value) {
            super(children);
            this.value = value;
        }

        public int getValue(){
            return value;
        }
    }
</code>
</pre>
   
   
트리를 보면 최상위 노드는 하나뿐이다.   
이 노드에서 시작해서 화살표를 따라가면 다른 모든 노드에 도달할 수 있다. 이런 최상위 노드를 루트(root)라고 부른다.   
루트는 다른 모든 노드로 가는 경로가 반드시 존재해야만 하는 유일한 노드이다. **따라서 모든 트리의 시작점은 바로 루트다.**   
그렇다 보니 트리의 루트 노드를 그냥 "트리"라고 부르는 경우도 흔하게 볼 수 있다.   
   
트리와 관련된 용어들을 몇 가지 정리해보면 다음과 같다.   

* 부모(parent) - 다른 노드를 가리키는 노드는 그 노드의 부모가 된다. 루트를 제외한 모든 노드에는 부모가 하나씩 있다. 
* 자식(child)  - 루트를 제외한 모든 노드는 그 노드를 가리키는 노드의 자식이 된다.   
* 자손(Descendant) - 특정 노드로부터 자식 노드로 이어지는 경로를 따라 도달할 수 있는 모든 노드는 그 특정 노드의 자손이다.   
* 조상(Ancestor) - 어떤 노드를 자손으로 삼고 있는 노드는 모두 그 노드의 조상이다.   
* 잎(Leaves) - 자식이 없는 노드를 잎이라고 부른다.   
   
    
------------------------

## 이진 트리   
   
   
실전에서 인터뷰어가 "트리"라고 말한다면 보통 이진 트리(binary tree)라는 트리의 한 종류를 일컫는 경우가 많다.   
이진 트리에서는 한 노드에 자식이 최대 두개까지만 있을 수 있으며, 그 두 자식은 각각 왼쪽 자식과 오른쪽 자식이라고 부른다.   
이진 트리를 간단하게 구현하면 다음과 같다.   

<pre>
</code>
    public class Node{
        private Node left;
        private Node right;
        private int value;

        public Node(Node left, Node right, int value) {
            this.value = value;
            this.right = right;
            this.left = left;
        }

        public Node getLeft(){ return left; }
        public Node getRight(){ return  right; }
        public int getValue(){ return value; }
    }
</code>
</pre>

어떤 원소에 왼쪽 또는 오른쪽 자식이 없으면 left 또는 right 에 널 레퍼런스를 집어넣는다.   
인터뷰어가 "트리"라고 말한다면 일반적인 트리를 말하는 것인지 이진 트리를 말하는 거 ㅅ인지를 분명하게 해두는 편이 좋다.   

--------------------------

## 이진 검색 트리
   
트리를 써서 정렬된, 또는 순서가 정해진 자료를 저장하는 경우를 흔하게 볼 수 있다.   
그 중에서도 트리에 데이터를 저장할 때 가장 흔하게 쓰이는 것은 이진 검색 트리(BST, Binary Search Tree)이다.   
BST에서는 노드의 왼쪽 자식의 값이 반드시 자신의 값 이하이며, 오른쪽 자식의 값은 반드시 자신의 값 이상이다.   
사실 BST의 데이터는 값으로 정렬된다. 어떤 노드에서 왼쪽 방향의 자손들은 전부 그 노드 이하의 값을 가지며, 오른쪽 방향의 자손들은 모두 그 노드 이상의 값을 가진다.   
   
   
### 룩업(Lookup)
   
이진 검색 트리의 장점 가운데 하나로 룩업 연산(트리에 있는 특정 노드의 위치를 알아내는 연산)을 빠르고 간단하게 처리할 수 있다는 점을 들 수 있다.   
이런 장점은 자료를 저장할 때 그 위력을 발휘한다.   
알고리즘을 간단하게 적어보면 다음과 같다.   
  
<pre>
루트 노드에서 시작.
현재 노드가 널이 아닌 동안 반복.
    현재 노드의 값이 찾고자 하는 값이면
        현재 노드 리턴
    현재 노드의 값이 찾고자 하는 값보다 작으면
        오른쪽 자식을 현재 노드로 설정
    현재 노드의 값이 찾고자 하는 값보다 크면
        왼쪽 자식을 현재 노드로 설정
반복문 끝
</pre>
   
루프가 그냥 종료된다면 찾고자 하는 노드가 트리에 없음을 알 수 있다.   
코드로 만들어보면 다음과 같다.

<pre>
<code>
    Node lookup(Node root, int value){
        while(root != null){
            int currval = root.getValue();
            if(currval == value) break;
            if(currval < value) {
                root = root.getRight();
            }else{
                root = root.getLeft();
            }
        }
        return root;
    }
</code>
</pre>
   
   
반복문이 한 번 돌때마다 왼쪽 서브 트리와 오른쪽 서브 트리 중 한쪽으로 넘어가기 때문에 한 번에 절반씩의 노드를 제쳐둘 수 있고, 결과적으로 룩업 연산이 빨라진다.   
이 룩업의 실행 시간은 1이 나올때까지 n을 2로 계속해서 나누는 회수가 된다.   
그 값은 n에 이를 때까지 1에 2를 계속 곱하는 회수하고 같으므로 2^x = n 이라는 식으로 구할 수 있다.   
이 x는 로그를 써서 구할 수 있다.   
예를 들어 2^3 = 8 이고 log8 = 3이므로, 룩업 연산의 실행 시간은 O(log(n))이다.   
*로그의 밑을 바꿔도 로그 앞에 상수가 붙는 정도밖에 차이가 나지 않기때문에 빅 오 표기법을 쓸 때는 로그의 밑을 생략한다.   
   
**이진 검색 트리에서는 룩업이 O(log(n)) 연산이다.   

하지만 최악의 경우에는 각 노드마다 자식이 하나씩만 있을 수도 있다.   
그런 경우에는 각 노드가 다른 노드를 하나씩만 가리키게 되기 때문에 연결 리스트와 같아진다.   
그러면 연결리스트를 쓸 때와 마찬가지로 O(n) 연산이 된다.   
하지만 다행히도 모든 노드의 왼쪽과 오른쪽으로 이어지는 노드의 수가 거의 항상 같도록 만드는 방법이 있다.   
양쪽에 있는 노드의 수가 거의 같은 트리를 균형 잡힌 트리(balanced tree)라고 부른다.   
모든 노드의 양쪽에 연결된 노드의 수가 거의 같도록 만들어주는 방법 가운데 가장 흔하게 쓰이는 것은 레드-블랙(red-black) 트리이다.   

**이진 검색 트리에서는 삭제 및 삽입도 O(log(n)) 연산이다.   
   
트리 문제 중에서는 재귀적으로 생각할 수 있는 능력을 평가하기 위한 것들이 많다.    
트리에 있는 각 노드는 그 노드에서 시작하는 서브 트리의 루트이다.   
재귀 호출은 일반적으로 어떤 기본 케이스의 원래 문제와 유사한 하부 문제를 가지고 문제를 푸는데 많이 쓰이기 때문에, 이와 같은 서브 트리의 속성은 재귀 호출과 잘 어울린다.   
   
예를 들어, 앞에서 설명한 룩업 연산을 다음과 같이 재귀적으로 구현할 수 있다.   



트리를 사용하는 문제 중 상당수는 이런 재귀 호출 형태로 풀 수 있다.   
트리와 연관된 문제를 풀 때는 우선 재귀적으로 생각하는 것부터 시작하는 것이 좋다.   
**트리 연산 중 상당수는 재귀적으로 구현할 수 있다.
