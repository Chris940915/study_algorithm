[트리](#트리)   
[이진 트리](#이진-트리)   
[이진 검색 트리](#이진-검색-트리)   
[ - 룩업](#룩업(Lookup))   
[힙](#힙)   
[일반적인 검색 방법](#일반적인-검색-방법)   
[- 너비 우선 검색](#너비-우선-검색(BFS))   
[- 깊이 우선 검색](#깊이-우선-검색(DFS))   
[종주](#종주)
[그래프](#그래프)   
[이진 트리 문제](#이진-트리-문제)   
[ - 프리오더 종주](#프리오더-종주)   
[- 재귀 호출을 쓰지 않는 프리오더 종주](#재귀-호출을-쓰지-않는-프리오더-종주)




---------------------------------------
   
트리와 그래프는 프로그래밍에서 흔히 쓰이는 자료구조이기 때문에 프로그래밍 인터뷰에도 자주 등장한다.   
그 중에서도 트리는 지원자의 재귀 호출과 실행 시간 분석에 관한 지식을 테스트하기에 안성맞춤.   
게다가 트리는 간단한 편이여서 인터뷰를 진행하는 비교적 짧은 시간 동안 구현하기에도 적당하다.   
그래프 문제도 흥미롭긴 하지만 대체로 너무 복잡한 편이어서 인터뷰용 문제로 쓰기에는 안좋다.   
이런 이유 때문에 이 장에서는 주로 트리에 초점을 맞춘다.     
C# 이나 자바 같은 현대적인 언어를 사용해보자.   

# 트리   
   
## 개요   
   
트리는 0개 이상의 다른 노드에 대한 레퍼런스가 들어있는 노드(데이터 원소)로 구성된다.   
한 노드를 참조하는 노드는 하나뿐이다.   
연결리스트와 마찬가지로 노드도 구조체 또는 클래스로 표현되며, 트리는 포인터 또는 레퍼런스만 있다면 어떤 언어로든 구현할 수 있다.   
  
객체지향 언어에서는 보통 노드의 공통적인 부분을 하나의 클래스로 정의하고, 노드에 들어가는 데이터를 위해 서브클래스를 만들어서 사용한다.     
예를 들어, 정수가 저장되는 트리를 만들고 싶다면 다음과 같은 클래스를 사용하면 된다. 

<pre>
<code>
    public abstract class Node{
        private Node[] children;

        public Node(Node[] children){
            this.children = children;
        }

        public int getNumChildren(){
            return children.length;
        }

        public Node getChild(int index){
            return children[index];
        }
    }

    class IntNode extends Node {
        private int value;

        public IntNode(Node[] children, int value) {
            super(children);
            this.value = value;
        }

        public int getValue(){
            return value;
        }
    }
</code>
</pre>
   
   
트리를 보면 최상위 노드는 하나뿐이다.   
이 노드에서 시작해서 화살표를 따라가면 다른 모든 노드에 도달할 수 있다. 이런 최상위 노드를 루트(root)라고 부른다.   
루트는 다른 모든 노드로 가는 경로가 반드시 존재해야만 하는 유일한 노드이다. **따라서 모든 트리의 시작점은 바로 루트다.**   
그렇다 보니 트리의 루트 노드를 그냥 "트리"라고 부르는 경우도 흔하게 볼 수 있다.   
   
트리와 관련된 용어들을 몇 가지 정리해보면 다음과 같다.   

* 부모(parent) - 다른 노드를 가리키는 노드는 그 노드의 부모가 된다. 루트를 제외한 모든 노드에는 부모가 하나씩 있다. 
* 자식(child)  - 루트를 제외한 모든 노드는 그 노드를 가리키는 노드의 자식이 된다.   
* 자손(Descendant) - 특정 노드로부터 자식 노드로 이어지는 경로를 따라 도달할 수 있는 모든 노드는 그 특정 노드의 자손이다.   
* 조상(Ancestor) - 어떤 노드를 자손으로 삼고 있는 노드는 모두 그 노드의 조상이다.   
* 잎(Leaves) - 자식이 없는 노드를 잎이라고 부른다.   
   
    
------------------------

## 이진 트리   
   
   
실전에서 인터뷰어가 "트리"라고 말한다면 보통 이진 트리(binary tree)라는 트리의 한 종류를 일컫는 경우가 많다.   
이진 트리에서는 한 노드에 자식이 최대 두개까지만 있을 수 있으며, 그 두 자식은 각각 왼쪽 자식과 오른쪽 자식이라고 부른다.   
이진 트리를 간단하게 구현하면 다음과 같다.   

<pre>
</code>
    public class Node{
        private Node left;
        private Node right;
        private int value;

        public Node(Node left, Node right, int value) {
            this.value = value;
            this.right = right;
            this.left = left;
        }

        public Node getLeft(){ return left; }
        public Node getRight(){ return  right; }
        public int getValue(){ return value; }
    }
</code>
</pre>

어떤 원소에 왼쪽 또는 오른쪽 자식이 없으면 left 또는 right 에 널 레퍼런스를 집어넣는다.   
인터뷰어가 "트리"라고 말한다면 일반적인 트리를 말하는 것인지 이진 트리를 말하는 거 ㅅ인지를 분명하게 해두는 편이 좋다.   

--------------------------

## 이진 검색 트리
   
트리를 써서 정렬된, 또는 순서가 정해진 자료를 저장하는 경우를 흔하게 볼 수 있다.   
그 중에서도 트리에 데이터를 저장할 때 가장 흔하게 쓰이는 것은 이진 검색 트리(BST, Binary Search Tree)이다.   
BST에서는 노드의 왼쪽 자식의 값이 반드시 자신의 값 이하이며, 오른쪽 자식의 값은 반드시 자신의 값 이상이다.   
사실 BST의 데이터는 값으로 정렬된다. 어떤 노드에서 왼쪽 방향의 자손들은 전부 그 노드 이하의 값을 가지며, 오른쪽 방향의 자손들은 모두 그 노드 이상의 값을 가진다.   
   
   
### 룩업(Lookup)
   
이진 검색 트리의 장점 가운데 하나로 룩업 연산(트리에 있는 특정 노드의 위치를 알아내는 연산)을 빠르고 간단하게 처리할 수 있다는 점을 들 수 있다.   
이런 장점은 자료를 저장할 때 그 위력을 발휘한다.   
알고리즘을 간단하게 적어보면 다음과 같다.   
  
<pre>
루트 노드에서 시작.
현재 노드가 널이 아닌 동안 반복.
    현재 노드의 값이 찾고자 하는 값이면
        현재 노드 리턴
    현재 노드의 값이 찾고자 하는 값보다 작으면
        오른쪽 자식을 현재 노드로 설정
    현재 노드의 값이 찾고자 하는 값보다 크면
        왼쪽 자식을 현재 노드로 설정
반복문 끝
</pre>
   
루프가 그냥 종료된다면 찾고자 하는 노드가 트리에 없음을 알 수 있다.   
코드로 만들어보면 다음과 같다.

<pre>
<code>
    Node lookup(Node root, int value){
        while(root != null){
            int currval = root.getValue();
            if(currval == value) break;
            if(currval < value) {
                root = root.getRight();
            }else{
                root = root.getLeft();
            }
        }
        return root;
    }
</code>
</pre>
   
   
반복문이 한 번 돌때마다 왼쪽 서브 트리와 오른쪽 서브 트리 중 한쪽으로 넘어가기 때문에 한 번에 절반씩의 노드를 제쳐둘 수 있고, 결과적으로 룩업 연산이 빨라진다.   
이 룩업의 실행 시간은 1이 나올때까지 n을 2로 계속해서 나누는 회수가 된다.   
그 값은 n에 이를 때까지 1에 2를 계속 곱하는 회수하고 같으므로 2^x = n 이라는 식으로 구할 수 있다.   
이 x는 로그를 써서 구할 수 있다.   
예를 들어 2^3 = 8 이고 log8 = 3이므로, 룩업 연산의 실행 시간은 O(log(n))이다.   
*로그의 밑을 바꿔도 로그 앞에 상수가 붙는 정도밖에 차이가 나지 않기때문에 빅 오 표기법을 쓸 때는 로그의 밑을 생략한다.   
   
**이진 검색 트리에서는 룩업이 O(log(n)) 연산이다.   

하지만 최악의 경우에는 각 노드마다 자식이 하나씩만 있을 수도 있다.   
그런 경우에는 각 노드가 다른 노드를 하나씩만 가리키게 되기 때문에 연결 리스트와 같아진다.   
그러면 연결리스트를 쓸 때와 마찬가지로 O(n) 연산이 된다.   
하지만 다행히도 모든 노드의 왼쪽과 오른쪽으로 이어지는 노드의 수가 거의 항상 같도록 만드는 방법이 있다.   
양쪽에 있는 노드의 수가 거의 같은 트리를 균형 잡힌 트리(balanced tree)라고 부른다.   
모든 노드의 양쪽에 연결된 노드의 수가 거의 같도록 만들어주는 방법 가운데 가장 흔하게 쓰이는 것은 레드-블랙(red-black) 트리이다.   

**이진 검색 트리에서는 삭제 및 삽입도 O(log(n)) 연산이다.   
   
트리 문제 중에서는 재귀적으로 생각할 수 있는 능력을 평가하기 위한 것들이 많다.    
트리에 있는 각 노드는 그 노드에서 시작하는 서브 트리의 루트이다.   
재귀 호출은 일반적으로 어떤 기본 케이스의 원래 문제와 유사한 하부 문제를 가지고 문제를 푸는데 많이 쓰이기 때문에, 이와 같은 서브 트리의 속성은 재귀 호출과 잘 어울린다.   
   
예를 들어, 앞에서 설명한 룩업 연산을 다음과 같이 재귀적으로 구현할 수 있다.   

<pre>
<code>
    Node findNode(Node root, int value) {
        if( root == null ) return null;
        int curval = root.getValue();
        if( currval == value) break;
        if( crrval < value ){ 
            findNode(root.getRight(), value);
        }else{
            findNode(root.getLeft(), value);
        }
   }
</code>
</pre>

트리를 사용하는 문제 중 상당수는 이런 재귀 호출 형태로 풀 수 있다.   
트리와 연관된 문제를 풀 때는 우선 재귀적으로 생각하는 것부터 시작하는 것이 좋다.   
**트리 연산 중 상당수는 재귀적으로 구현할 수 있다.


## 힙   
   
힙도 매우 많이 쓰이는 트리 가운데 하나다.   
힙은 조금 특이한 형태의 트리(보통 이진 트리)로, 노드의 각 자식의 값은 노드 자신의 값 이하여야 한다.   
결과적으로 루트 노드의 값은 그 트리에서 가장 큰 값이며, 최대값을 상수 시간으로 구하는 것이 가능하다.   
*루트 값을 리턴하기만 하면 되기 때문이다.*    
**삽입과 삭제는 앞과 마찬가지로 여전히 O(log(n))이지만 룩업은 O(n)연산이다.**   
그리고 BST의 경우에서처럼 주어진 노드 다음으로 큰 노드를 O(log(n))시간으로 찾는다거나 O(n)시간으로 모든 노드를 정렬된 순서로 출력할 수는 없다.   
우선순위가 가장 높은 순서를 찾을 수 있으며, 이 연산은 상수 시간으로 처리된다.   
**빠르게 최대값(우선순위가 높은 값)을 추출해야 한다면 힙을 사용한다.**   
   
## 일반적인 검색 방법    
   
BST나 힙처럼 정렬되는 특성을 가진 트리를 쓰면 문제 해결이 꽤 편해지는 경우가 종종 있다.   
하지만 다른 트리가 주어지는 경우도 있다.   
예를 들어, 가계도나 회사 직위체계 등을 나타내는 트리가 주어지는 경우가 있다.   
이런 유형의 트리에서 데이터를 가져오려면 다른 기법을 써야만 한다.   
트리 관한 문제 중에서는 이렇게 특정 노드를 검색하는 것과 관련된 문제들이 자주 나온다.   
여기에서는 대표적인 알고리즘 두가지를 알아보자.   
   
### 너비 우선 검색(BFS)
   
트리를 검색하는 방법 가운데 하나로 너비 우선 검색(BFS, Breadth-First-Search)이 있다.   
BFS에서는 루트에서 시작하여 둘째 층을 왼쪽에서 오른쪽으로 훑어나가고, 그 다음 층을 또 왼쪽에서 오른쪽으로 훑어나가는 식으로 검색을 한다.   
원하는 노드를 찾거나 모든 노드를 다 확인해보고 나면 검색이 끝난다.    
노드를 찾아내는 데 걸리는 시간은 O(n)이기 때문에 큰 트리에 대해서는 이런식으로 검색을 하지 않는 것이 좋다.   
BFS에서는 어떤 층을 검색할 때 그 층에 있는 모든 노드의 자식 노드를 저장해둬야 하기 때문에 메모리도 꽤 많이 사용해야 한다.   
   
### 깊이 우선 검색(DFS)   

또 다른 검색 방법으로 깊이 우선 검색(DFS, Depth-First Search)이 있다.    
깊이 우선 검색은 원하는 노드를 찾을 떄까지, 또는 끝에 다다를때까지 한 가지를 따라 쭉 내려가는 방식이다.   
더 이상 검색을 진행할 수 없으면 아직 확인해보지 않은 자식이 있는 가장 가까운 조상 노드를 돌아가서 검색을 계속 진행한다.   
DFS에서는 각 층별로 모든 자식 노드를 저장해야 할 필요가 없기 때문에 BFS에 비해 메모리 요구량이 훨씬 적다.   
그리고 특정 층을 마지막으로 검색하는 문제가 없다는 것도 장점이 될 수 있다.
   
   
## 종주   
   

종주(traversal)도 자주 나오는 문제 유형 가운데 하나.   
특정 노드를 찾으면 작업을 멈추는 검색과는 달리 종주를 할 때는 모든 노드를 방문하면서 각 노드에 대해 어떤 작업을 수행하게 된다.    
종주에도 여러 방법이 있으며, 각 방법에 따라 노드를 방문하는 순서가 달라지는데 그 중에서 인터뷰 시에는 이진 트리를 종주할 때 많이 쓰이는 세가지 방법에 대한 질문이 주로 나온다.   
   
* 프리오더(Preorder) 종주 - 우선 **노드 자체에 어떤 작업을 수행하고 왼쪽 자손을 처리한 다음 오른쪽 자손을 처리한다.** 즉, 항상 노드를 자식들보다 먼저 방문한다.   
* 인오더(Inorder) 종주 - 우선 **노드의 왼쪽 자손 자손에 대해 작업을 수행한 다음 노드 자체에 대해 작업을 수행하고, 마지막으로 오른쪽 자손을 처리한다.** 즉, 왼쪽 서브 트리를 먼저 방문하고 노드 자체를 방문한 다음 오른쪽 서브 트리를 방문하게 된다.   
* 포스트오더(Postorder) 종주 - 우선 **노드의 왼쪽 자손에 대해 작업을 수행한 다음 오른쪽 자손에 대해 작업을 수행하고, 마지막으로 그 노드 자체를 처리한다.** 즉, 모든 자식들을 자기 자신보다 먼저 처리한다.   
   
   
이러한 종주 방법은 자식이 부모 노드보다 "작다(왼쪽에 있다)" 또는 "크다(오른쪽에 있다)"고 분류할 수 있는 특성을 가지는 트리라면, 이진 트리가 아닌 트리에서도 적용할 수 있다.   
종주를 구현하는 간단한 방법은 재귀 호출을 이용하는 방법.    
이 장에 나와 있는 문제를 통해 그 예를 볼 수 있다.   
**종주를 구현하는 문제가 나온다면 우선 재귀호출 부터 생각해보자.**   
   
   
## 그래프   
   
그래프는 트리보다 복잡.   
자식이 딸린 노드로 구성되는 점은 같지만, 트리와 달리 한 노드에 부모가 여럿 있을 수 있어서 루프(사이클)가 만들어질 수 있다는 점이 다르다.   
그리고 노드 자체가 아닌 노드 사이의 링크에도 값 또는 가중치가 있을 수 있다.   
이렇게 다른 노드를 가리키는 기능 외에 별도의 정보를 담을 수 있는 링크를 에지(edge)라고 부른다.   
에지는 단방향 에지와 양방향 에지가 있으며, 단방향 에지가 들어있는 그래프는 방향성 그래프(directed graph), 양방향 에지만 들어있는 그래프는 무방향성 그래프(undirected graph)라고 부른다.   
   
그래프는 다른 자료구조로는 모형화하기 힘든 실전 문제를 모형화할 때 자주 쓰인다.   
예를 들어, 도시들을 연결하는 수로는 방향성 그래프로 표현할 수 있다.   
   
트리와 달리 코드에서 그래프의 자료구조를 표현하는 방법은 매우 다양하다.    
종종 구현할 알고리즘에 따라 그래프 표현법을 다르게 선택할 수도 있다. 실전 프로그래밍에서는 종종 쓰이지만, 인터뷰를 하는 시간 동안에는 풀기 힘들기 때문에 그래프의 정의에 대해 간략한 설명 정도면 충분하리라 생각.   

-----------------------------
## 이진 트리 문제   
   
이진 트리는 가장 흔하게 쓰이는 유형의 트리. 

### 프리오더 종주
   
<pre>
   프리오더 종주는 루트에서 시작해서 트리를 반시계 방향으로 돌면서 가장자리를 따라 움직이면 만나게 되는 노드를 출력하는 방식으로 생각할 수 있다.   
   이진 검색 트리에 대해 프리오더 종주를 하면서 각 노드의 값을 출력하라.
</pre>
   
노드를 주어진 순서에 맞게 출력하는 알고리즘을 찾아내기 위해 노드를 출력할 때 어떤 일이 일어나는지 살펴보자.   
우선 왼쪽으로 끝까지 내려간 다음 위로 올라와서 오른쪽으로 한 칸 움직인다.   
그런 후 또 왼쪽으로 끝까지 내려갔다가 다시 올라오고, 이와 유사한 과정을 계속해서 반복한다.   
여기서 가장 중요한 것은 서브 트리를 기준으로 생각하는 것이다.   
프리오더 종주는 노드 자체를 출력한 다음 왼쪽 서브 트리를 출력한 후에 오른쪽 서브 트리를 출력한다.   
다음과 같은 식으로 재귀적으로 정의할 수 있다.   
   
   1. 루트(또는 서브 트리의 루트) 값을 출력한다.   
   2. 왼쪽 서브 트리에 대해 프리오더 종주를 시행한다.   
   3. 오른쪽 서브 트리에 대해 프리오더 종주를 시행한다.   
   4. Node 클래스는 이진 검색 트리와 비슷한 식으로 정의하고 각 노드의 값을 출력하기 위한 printValue 메소드를 클래스에 추가한다.   
      프리오더 종주는 재귀 호출을 이용하면 쉽게 코딩할 수 있다.   

<pre>
<code>
   void preorderTraversal( Node root ) {
      if (root==null) return;
      root.printValue();
      preorderTraversal( root.getLeft() );
      preorderTraversal( root.getRight() );
   }
</pre>
</code>
   
이 알고리즘의 실행 시간은 어떻게 될까? 모든 노드를 한 번씩 확인해야 하므로 O(n)이 된다.   
인오더 및 포스트 오더 종주도 거의 똑같은 식으로 처리하면 된다.   
   
<pre>
<code>
   void inorderTraversal( Node root ) {
      if ( root == null ) return;
      inorderTraversal( root.getLeft() );
      root.printValue();
      inorderTraversal( root.getRight() );
   }
   
   
   void postorderTraversal( Node root ) {
      if ( root == null ) return;
      postorderTraversal( root.getLeft() );
      postorderTraversal( root.getRight() );
      root.printValue();
   }
   
</pre>
</code>
   
이 두 알고리즘의 실행 시간도 마찬가지로 모두 O(n) 이다.   

### 재귀 호출을 쓰지 않는 프리오더 종주
   
<pre>
  이진 검색 트리의 각 노드를 출력하는 프리오더 종주를 수행하라.   
  재귀 호출은 쓸 수 없다.   
</pre>
    
재귀적인 알고리즘을 반복문을 이용한 알고리즘으로 바꿔서 똑같은 작업을 다른 자료구조로 전혀 다른 방식으로 처리할 수도 있다.   
예를 들어, 리스트, 배열, 또 다른 이진 트리 등을 시도해볼 수 있을 것이다.   
   
그런데 프리오더 종주는 기본 개념의 정의 자체가 재귀적인 성질을 지니고 있기 때문에 재귀적인 알고리즘 대신 쓸 만한 반복형 알고리즘을 찾아내는 것이 간단하지가 않다.   
그런 경우에는 재귀 호출 과정에서 어떤 일이 일어나는지 확인해보고, 그 절차들을 반복문을 써서 처리하는 방법을 알아내는 것이 급선무라고 할 수 있다.   
   
재귀 호출을 할 때는 데이터를 호출 스택에 집어넣는 식으로 스택 데이터를 사용하기 마련이다.   
즉, 명시적으로 
